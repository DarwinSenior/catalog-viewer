<link rel="import" href="../bower_components/polymer/polymer.html">
<script src="../scripts/Drawer.js"></script>
<script src="../scripts/L.SVGLayer.js"></script>
<dom-module id="ellipse-map">
  <style>
    :host {
      display: block;
      position: relative;
      height: 100%;
      width: 100%;
    }
  </style>
  <template>
    <div id="map" style="width: 100%; height: 100%; background-color: black;"></div>
  </template>
</dom-module>
<script>
(function() {
  Polymer({
    is: 'ellipse-map',

    properties: {
      url : {
        type : String
      },
      maxZoom : {
        type : Number,
        value : 18
      },
      data : {
        type : Object,
        value : {},
        notify : true,
        observer : "_reloadMap"
      },
      requiredinfo : {
        type : Object,
        value : {},
        notify : true
      },
      colorscheme : {
        type : Object,
        notify : true,
        observer : 'changeColor'
      }
    },
    ready : function(){
      this.drawer = new Drawer();
      this.drawer.changeEvent((function(d, i){
        var data = [];
        for (var i=0; i < (this.data.HEADER || []).length; i++){
          var key = this.data.HEADER[i];
          data.push({name : key, value : d[key].toString()});
        }
        this.requiredinfo = data;
      }).bind(this));
    },
    attached : function(){
      this.map = L.map(this.$.map).setView([-1.076704067725527,143.09487462043765], 16);
      this._addLayer();
    },
    _addLayer : function(){
      if (this.data._id){
        var url = "/tile/"+this.data._id+"/{z}/{x}/{y}.json";
        this.vector_layer = new L.SVGLayer(url, {
          maxZoom : this.maxZoom,
          attribution : "YDC"
        }, 
        this.drawer.drawer.bind(this.drawer), 
        this.drawer.cleaner.bind(this.drawer));
        this.map.addLayer(this.vector_layer);
      }
    },
    _reloadMap : function(){
      if (this.vector_layer){
        this.map.removeLayer(this.vector_layer);
        this.vector_layer = undefined;
      }
        this._addLayer();
    },
    /*
    The color scheme of type Data -> Color
    where Data is a dictionary specified by json file returned
    Example {RA : <Number>, DEC : <Number>, THETA : <Number> ...}
    where Color is a string which conforms to CSS spec for color 
    Example : "white" || "#00000" || "rgb(0,0,0)"
    */
    changeColor : function(scheme){
      if (scheme && scheme.selected && this.data){
        var min = scheme.rangeleft;
        var max = scheme.rangeright;
        colorAlg = function(d){
          var scale = Math.max(0, Math.min((d[scheme.selected]-min)/(max-min), 1));
          return d3.interpolateHsl(scheme.mincolor || 'white', scheme.maxcolor || 'white')(scale);
        }
        this.drawer.changeColor(colorAlg);
      }
    },
    /*
    The position returns {zoom: <int>, center: <LatLng>} 
    if newValue is defined, the map will set new position 
    and return the newest position, and newValue shall
    be in the form {zoom: <int>, center: <LatLng>}
    */
    position : function(newValue){
      if (newValue){
        this.map.setView(newValue);
      }
      return this.map.getView();
    },
    /*
    Set to the center of the coverage of the map,
    and find the appropriate zoom level
    */
    setDefaultPosition : function(){
      var midpoint = this._RADEC2Scale([
        (this.data.RA.max+this.data.RA.min)/2,
        (this.data.DEC.max+this.data.DEC.min)/2]);
      var pos = this.map.layerPointToLatLng(midpoint);
      this.map.setView(pos);
      this.map.setZoom(10);
    },
    resize : function(){
      this.map.invalidateSize(true);
    },
    _parseData : function(){
      var data = this.data;
    },
    /*
    The input shall be a pair of ra and dec,
    thus, output the ratio of where the point is located
    */
    _RADEC2Scale : function(point){
      // lng = item['RA'] - 180
      // lat = item['DEC']
      var lng = point[0]-180,
          lat = point[1]
      return [(lng + 180)/360, (lat + 90)/180]
    }
  });
})();
</script>
